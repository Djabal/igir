{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"\ud83d\udd79\ufe0f igir <p>Pronounced \"eager,\" <code>igir</code> is a video game ROM collection manager to help filter, sort, patch, archive, and report on collections on any OS.</p> <p> </p> <p> </p> <p>See the project website for complete documentation, installation &amp; usage instructions, and examples!</p> <p></p>"},{"location":"#what-does-igir-do","title":"What does <code>igir</code> do?","text":"<p>A video of an example use case:</p> <p></p> <p>With <code>igir</code> you can manage a ROM collection of any size:</p> <ul> <li>\ud83d\udd0d Scan for DATs, ROMs, and ROM patches - including those in archives (see scanning &amp; archive docs)</li> <li>\ud83d\udcc2 Organize ROM files by console (see DAT docs)</li> <li>\ud83e\ude84 Name ROM files consistently, including the right extension (see DAT docs)</li> <li>\u2702\ufe0f Filter out duplicate ROMs, or ROMs in languages you don't understand (see filtering docs)</li> <li>\ud83d\udddc\ufe0f Extract or archive ROMs in mass (see archive docs)</li> <li>\ud83e\ude79 Patch ROMs automatically in mass (see scanning &amp; patching docs)</li> <li>\ud83c\udfa9 Parse ROMs with headers, and optionally remove them (see header docs)</li> <li>\ud83d\udd2e Report on what ROMs are present or missing for each console, and create fixdats for missing ROMs (see reporting &amp; DAT docs)</li> </ul>"},{"location":"#how-do-i-run-igir","title":"How do I run <code>igir</code>?","text":"<p>Either download the latest version for your OS from the releases page, or if you have Node.js installed you can use <code>npx</code> to always run the latest version from the command line:</p> <pre><code>npx igir@latest [commands..] [options]\n</code></pre> <p>Here is the full help message which shows all available options and a number of common use case examples:</p> <pre><code>$ igir --help\n\n ______   ______   ______  _______\n|      \\ /      \\ |      \\|       \\\n \\$$$$$$|  $$$$$$\\ \\$$$$$$| $$$$$$$\\\n  | $$  | $$ __\\$$  | $$  | $$__| $$\n  | $$  | $$|    \\  | $$  | $$    $$   ROM collection manager\n  | $$  | $$ \\$$$$  | $$  | $$$$$$$\\\n _| $$_ | $$__| $$ _| $$_ | $$  | $$   v1.8.2\n|   $$ \\ \\$$    $$|   $$ \\| $$  | $$\n \\$$$$$$  \\$$$$$$  \\$$$$$$ \\$$   \\$$\n\nUsage: igir [commands..] [options]\n\nCommands (can specify multiple):\n  igir copy     Copy ROM files from the input to output directory\n  igir move     Move ROM files from the input to output directory\n  igir symlink  Create symlinks in the output directory to ROM files in the input directory\n  igir extract  Extract ROM files in archives when copying or moving\n  igir zip      Create zip archives of ROMs when copying or moving\n  igir test     Test ROMs for accuracy after writing them to the output directory\n  igir clean    Recycle unknown files in the output directory\n  igir report   Generate a CSV report on the known &amp; unknown ROM files found in the input directo\n                ries (requires --dat)\n\nInput options (supports globbing):\n  -i, --input          Path(s) to ROM files or archives                        [array] [required]\n  -I, --input-exclude  Path(s) to ROM files or archives to exclude from processing        [array]\n  -p, --patch          Path(s) to ROM patch files or archives (supported: .aps, .bps, .dps, .ebp,\n                        .ips, .ips32, .ppf, .rup, .ups, .vcdiff, .xdelta)                 [array]\n  -P, --patch-exclude  Path(s) to ROM patch files or archives to exclude from processing  [array]\n\nDAT input options:\n  -d, --dat                Path(s) to DAT files or archives (supports globbing)           [array]\n      --dat-exclude        Path(s) to DAT files or archives to exclude from processing (supports\n                           globbing)                                                      [array]\n      --dat-regex          Regular expression of DAT names to process                    [string]\n      --dat-regex-exclude  Regular expression of DAT names to exclude from processing    [string]\n\nDAT output options:\n      --fixdat  Generate a fixdat of any missing games for every DAT processed (requires --dat)\n                                                                                        [boolean]\n\nROM output options:\n  -o, --output             Path to the ROM output directory (supports replaceable symbols, see be\n                           low)                                                          [string]\n      --dir-mirror         Use the input subdirectory structure for the output directory[boolean]\n  -D, --dir-dat-name       Use the DAT name as the output subdirectory                  [boolean]\n      --dir-letter         Append the first letter of the ROM name as an output subdirectory\n                                                                                        [boolean]\n      --dir-letter-limit   Limit the number ROMs in letter subdirectories, splitting into multipl\n                           e if necessary                                                [number]\n  -O, --overwrite          Overwrite any files in the output directory                  [boolean]\n      --overwrite-invalid  Overwrite files in the output directory that are the wrong filesize, c\n                           hecksum, or zip contents                                     [boolean]\n  -C, --clean-exclude      Path(s) to files to exclude from cleaning (supports globbing)  [array]\n\nROM zip command options:\n  -Z, --zip-exclude   Glob pattern of files to exclude from zipping                      [string]\n      --zip-dat-name  Group all ROMs from the same DAT into the same zip archive, if not excluded\n                       from zipping (enforces --dat-threads 1)                          [boolean]\n\nROM symlink command options:\n      --symlink-relative  Create symlinks as relative to the target path, as opposed to absolute\n                                                                                        [boolean]\n\nROM header options:\n      --header          Glob pattern of files to force header processing for             [string]\n  -H, --remove-headers  Remove known headers from ROMs, optionally limited to a list of comma-sep\n                        arated file extensions (supported: .a78, .fds, .lnx, .nes, .smc) [string]\n\nROM filtering options:\n  -x, --filter-regex          Regular expression of game names to filter to              [string]\n  -X, --filter-regex-exclude  Regular expression of game names to exclude                [string]\n  -L, --language-filter       List of comma-separated languages to filter to (supported: DA, DE,\n                              EL, EN, ES, FI, FR, IT, JA, KO, NL, NO, PT, RU, SV, ZH)    [string]\n  -R, --region-filter         List of comma-separated regions to filter to (supported: ARG, ASI,\n                              AUS, BRA, CAN, CHN, DAN, EUR, FRA, FYN, GER, GRE, HK, HOL, ITA, JPN\n                              , KOR, MEX, NOR, NZ, POR, RUS, SPA, SWE, TAI, UK, UNK, USA, WORLD)\n                                                                                         [string]\n      --no-bios               Filter out BIOS files, opposite of --only-bios            [boolean]\n      --no-device             Filter out MAME devies, opposite of --only-device         [boolean]\n      --no-unlicensed         Filter out unlicensed ROMs, opposite of --only-unlicensed [boolean]\n      --only-retail           Filter to only retail releases, enabling all the following \"no\" opt\n                              ions                                                      [boolean]\n      --no-demo               Filter out demo ROMs, opposite of --only-demo             [boolean]\n      --no-beta               Filter out beta ROMs, opposite of --only-beta             [boolean]\n      --no-sample             Filter out sample ROMs, opposite of --only-sample         [boolean]\n      --no-prototype          Filter out prototype ROMs, opposite of --only-prototype   [boolean]\n      --no-test-roms          Filter out test ROMs, opposite of --only-test-roms        [boolean]\n      --no-aftermarket        Filter out aftermarket ROMs, opposite of --only-aftermarket\n                                                                                        [boolean]\n      --no-homebrew           Filter out homebrew ROMs, opposite of --only-homebrew     [boolean]\n      --no-unverified         Filter out unverified ROMs, opposite of --only-unverified [boolean]\n      --no-bad                Filter out bad ROM dumps, opposite of --only-bad          [boolean]\n\nOne game, one ROM (1G1R) options:\n  -s, --single                 Output only a single game per parent (1G1R) (required for all opti\n                               ons below, requires --dat with parent/clone information) [boolean]\n      --prefer-verified        Prefer verified ROM dumps over unverified                [boolean]\n      --prefer-good            Prefer good ROM dumps over bad                           [boolean]\n  -l, --prefer-language        List of comma-separated languages in priority order (supported: DA\n                               , DE, EL, EN, ES, FI, FR, IT, JA, KO, NL, NO, PT, RU, SV, ZH)\n                                                                                         [string]\n  -r, --prefer-region          List of comma-separated regions in priority order (supported: ARG,\n                                ASI, AUS, BRA, CAN, CHN, DAN, EUR, FRA, FYN, GER, GRE, HK, HOL, I\n                               TA, JPN, KOR, MEX, NOR, NZ, POR, RUS, SPA, SWE, TAI, UK, UNK, USA,\n                                WORLD)                                                   [string]\n      --prefer-revision-newer  Prefer newer ROM revisions over older                    [boolean]\n      --prefer-revision-older  Prefer older ROM revisions over newer                    [boolean]\n      --prefer-retail          Prefer retail releases (see --only-retail)               [boolean]\n      --prefer-parent          Prefer parent ROMs over clones                           [boolean]\n\nReport options:\n      --report-output  Report output location (formatted with moment.js)\n                                       [string] [default: \"./igir_%YYYY-%MM-%DDT%HH:%mm:%ss.csv\"]\n\nHelp &amp; debug options:\n      --dat-threads     Number of DATs to process in parallel               [number] [default: 3]\n      --writer-threads  Maximum number of ROMs to write in parallel        [number] [default: 20]\n  -v, --verbose         Enable verbose logging, can specify up to three times (-vvv)      [count]\n  -h, --help            Show help                                                       [boolean]\n\n-------------------------------------------------------------------------------------------------\n\nAdvanced usage:\n\n  Tokens that are replaced when generating the output (--output) path of a ROM:\n    {datName}             The name of the DAT that contains the ROM (e.g. \"Nintendo - Game Boy\")\n    {datReleaseRegion}    The region of the ROM release (e.g. \"USA\"), each ROM can have multiple\n    {datReleaseLanguage}  The language of the ROM release (e.g. \"En\"), each ROM can have multiple\n    {gameType}            The type of the game (e.g. \"Retail\", \"Demo\", \"Prototype\")\n\n    {inputDirname}    The input file's dirname\n    {outputBasename}  Equivalent to \"{outputName}.{outputExt}\"\n    {outputName}      The output file's filename without extension\n    {outputExt}       The output file's extension\n\n    {pocket}  The ROM's core-specific /Assets/* directory for the Analogue Pocket (e.g. \"gb\")\n    {mister}  The ROM's core-specific /games/* directory for the MiSTer FPGA (e.g. \"Gameboy\")\n    {onion}   The ROM's emulator-specific /Roms/* directory for OnionOS/GarlicOS (e.g. \"GB\")\n\nExample use cases:\n\n  Merge new ROMs into an existing ROM collection and generate a report:\n    igir copy report --dat *.dat --input **/*.zip --input ROMs/ --output ROMs/\n\n  Generate a report on an existing ROM collection, without copying or moving ROMs (read only):\n    igir report --dat *.dat --input ROMs/\n\n  Organize and zip an existing ROM collection:\n    igir move zip --dat *.dat --input ROMs/ --output ROMs/\n\n  Produce a 1G1R set per console, preferring English ROMs from USA&gt;WORLD&gt;EUR&gt;JPN:\n    igir copy --dat *.dat --input **/*.zip --output 1G1R/ --dir-dat-name --single --prefer-langua\n    ge EN --prefer-region USA,WORLD,EUR,JPN\n\n  Copy all Mario, Metroid, and Zelda games to one directory:\n    igir copy --input ROMs/ --output Nintendo/ --filter-regex \"/(Mario|Metroid|Zelda)/i\"\n\n  Copy all BIOS files into one directory, extracting if necessary:\n    igir copy extract --dat *.dat --input **/*.zip --output BIOS/ --only-bios\n\n  Create patched copies of ROMs in an existing collection, not overwriting existing files:\n    igir copy extract --input ROMs/ --patch Patches/ --output ROMs/\n\n  Copy ROMs to an Analogue Pocket and test they were written correctly:\n    igir copy extract test --dat *.dat --input ROMs/ --output /Assets/{pocket}/common/ --dir-lett\n    er\n</code></pre>"},{"location":"#feature-requests-bug-reports-and-contributing","title":"Feature requests, bug reports, and contributing","text":"<p>Feedback is a gift! Your feature requests and bug reports help improve the project for everyone. Feel free to submit an issue on GitHub using one of the templates.</p> <p>Even better, if you feel comfortable writing code, please feel free to submit a pull request against the project!</p> <p></p> <p> </p>"},{"location":"alternatives/","title":"Alternative Managers","text":"<p>There are a few different popular ROM managers that have similar features:</p> Feature igir clrmamepro RomVault Romcenter Romulus Code: still in development \u2705 \u2705 \u2705 \u2753 \u2753 Code: open source \u2705 GPL \u274c \u274c \u274c \u2753 App: OS compatibility \u2705 anything Node.js supports \u26a0\ufe0f Windows, macOS &amp; Linux via Wine \u26a0\ufe0f Windows, Linux via Mono \u274c Windows only \u2753 App: UI or CLI CLI only by design UI only Separate UI &amp; CLI versions UI only \u2753 App: required setup steps \u2705 no setup required \u274c requires \"profile\" setup per DAT \u26a0\ufe0f if specifying DAT &amp; ROM dirs \u274c requires per-DAT DB setup \u2753 DATs: supported formats \u2705 Logiqx XML, CMPro, HTGD SMDB \u2705 Logiqx XML, CMPro \u2705 Logiqx XML, CMPro \u2705 Logiqx XML, CMPro \u2753 DATs: built-in download manager \u274c \u274c \u26a0\ufe0f via DatVault \u274c \u2753 DATs: supports DAT URLs \u2705 \u274c \u274c \u274c \u2753 DATs: process multiple at once \u2705 \u26a0\ufe0f via the batcher \u2705 \u274c \u2753 DATs: create from files \u274c \u2705 \u2705 \u274c \u2753 DATs: combine multiple \u274c \u274c \u2705 \u274c \u2753 Archives: extraction formats \u2705 many formats (archive docs) \u2705 <code>.zip</code>, <code>.7z</code>, <code>.rar</code> \u26a0\ufe0f <code>.zip</code>, <code>.7z</code> \u26a0\ufe0f <code>.zip</code>, <code>.7z</code> \u2753 Archives: creation formats \u274c <code>.zip</code> only by design \u2705 <code>.zip</code>, <code>.7z</code>, <code>.rar</code> \u26a0\ufe0f <code>.zip</code>, <code>.7z</code> \u26a0\ufe0f <code>.zip</code>, <code>.7z</code> \u2753 ROMs: CHD scanning \u274c \u26a0\ufe0f via chdman \u26a0\ufe0f v1-5 natively, chdman for v5 \u26a0\ufe0f v1-4 natively \u2753 ROMs: scan/checksum caching \u274c by design \u274c \u2705 \u2705 \u2753 ROMs: header parsing \u2705 \u2705 \u2705 \u2705 via plugins \u2753 ROMs: header removal \u2705 \u274c \u274c \u274c \u2753 ROMs: patching support \u2705 patching docs \u274c \u26a0\ufe0f SNES SuperDAT \u274c \u2753 Filtering: region, language, type, etc. \u2705 many options \u274c only 1G1R options \u274c \u26a0\ufe0f only at DB setup \u2753 Filtering: 1G1R support \u2705 many options \u26a0\ufe0f region &amp; language only \u274c \u26a0\ufe0f only at DB setup \u2753 Reports: report-only mode \u2705 \u2705 \u2705 \u2705 \u2753 Reports: easily parseable \u2705 CSV \u26a0\ufe0f newline-separated \"have\" &amp; \"miss\" lists \u26a0\ufe0f newline-separated \"full\" &amp; \"fix\" reports \u26a0\ufe0f newline-separated \"have\" &amp; \"miss\" lists \u2753 Output: separate input &amp; output dirs \u2705 \u274c \u26a0\ufe0f yes but files are always moved \u274c \u2753 Output: subdirectory customization \u2705 \u274c \u2705 \u274c \u2753 Output: fixdat creation \u2705 dats docs \u2705 \u2705 \u274c \u2753"},{"location":"archives/","title":"Archives","text":"<p><code>igir</code> supports scanning the contents of archives for ROMs, DATs, and ROM patches.</p>"},{"location":"archives/#supported-archive-types-for-writing","title":"Supported archive types for writing","text":"<p><code>igir</code> only supports creating <code>.zip</code> archives, which is why the command is <code>igir zip</code>.</p> <p><code>.zip</code> archives store CRC32 information in the file table (see below) which helps drastically speed up file scanning, and they are easy to create without proprietary tools (e.g. Rar).</p>"},{"location":"archives/#supported-archive-types-for-reading","title":"Supported archive types for reading","text":"<p><code>igir</code> supports most common archive formats:</p> Extension Contains file CRC32s <code>igir</code> can extract natively <code>.7z</code> \u2705 \u274c <code>.gz</code>, <code>.gzip</code> \u274c CRC16 \u274c <code>.rar</code> \u2705 \u274c <code>.tar</code> \u274c \u2705 <code>.tar.gz</code>, <code>.tgz</code> \u274c \u2705 <code>.z01</code> \u2705 \u274c <code>.zip</code> (including zip64) \u2705 \u2705 <code>.zip.001</code> \u2705 \u274c <code>.zipx</code> \u2705 \u274c <p>You should prefer archive formats that have CRC32 checksum information for each file.</p> <p><code>igir</code> uses CRC32 information to match ROMs to DAT entries. If an archive already contains CRC32 information for each file, then <code>igir</code> won't need to extract each file and compute its CRC32 itself. This can save a lot of time on large files especially.</p> <p>This is why you should use the <code>igir zip</code> command when organizing your primary ROM collection. It is much faster to scan archives with CRC32 information, speeding up actions such as merging new ROMs into an existing collection.</p> <p>You should prefer archive formats that <code>igir</code> can extract natively.</p> <p>Somewhat proprietary archive formats such as <code>.7z</code> and <code>.rar</code> require <code>igir</code> to use an external tool to enumerate and extract files. This can greatly slow down processing speed.</p> <p>This is why <code>igir</code> uses <code>.zip</code> as its output archive of choice, <code>.zip</code> files are easy and fast to read, even if they can't offer as high of compression as other formats.</p>"},{"location":"commands/","title":"Commands","text":"<p><code>igir</code> takes actions based on commands you specify. Each command has a clear input and output, and <code>igir</code> will never take surprise actions you did not specify. Multiple commands can (and will likely) be specified at once.</p> <p>Tip</p> <p>See the <code>igir --help</code> message for the list of all commands and options, as well as some examples.</p>"},{"location":"commands/#rom-writing","title":"ROM writing","text":"<p><code>igir</code> has three writing commands. Only one writing command can be specified at a time, and all require the <code>--output</code> option.</p>"},{"location":"commands/#copy","title":"<code>copy</code>","text":"<p>Copy ROMs from an input directory to the output directory.</p> <p>Files in the input directories will be left alone, they will not be modified or deleted.</p>"},{"location":"commands/#move","title":"<code>move</code>","text":"<p>Move ROMs from an input directory to the output directory. The same directory can be specified for both input &amp; output, resulting in ROMs being renamed as their names change in DATs.</p> <p>ROMs will be deleted from their input directory after all ROMs for every DAT have been written.</p>"},{"location":"commands/#symlink","title":"<code>symlink</code>","text":"<p>Create a symbolic link in the output directory to a ROM in the input directory.</p> <p>By default, absolute file paths will be used. You can specify the <code>--symlink-relative</code> option to use relative file paths.</p>"},{"location":"commands/#rom-archiving","title":"ROM archiving","text":"<p><code>igir</code> has two ROM archive commands. Archive commands require either the <code>copy</code> or <code>move</code> write command. Only one archive command can be specified at a time.</p> <p>If no archive command is specified, files will be left as-is. If they are already extracted, then they will stay extracted. If they are already archived (including non-<code>.zip</code> archives), then they will stay archived.</p> <p>Note</p> <p>See the archives page for more information on supported archive types.</p>"},{"location":"commands/#extract","title":"<code>extract</code>","text":"<p>ROMs will be extracted from archives as they are being copied or moved. ROMs from the same game will be placed into a subdirectory together.</p> <p>Input ROMs that are not archived will be copied as-is.</p>"},{"location":"commands/#zip","title":"<code>zip</code>","text":"<p>ROMs will be archived into a <code>.zip</code> file as they are being copied or moved. ROMs from the same game will be put into the same <code>.zip</code> file.</p> <p>ROMs that are already in an archive will be re-archived.</p>"},{"location":"commands/#rom-verification","title":"ROM verification","text":""},{"location":"commands/#test","title":"<code>test</code>","text":"<p>After performing one of the ROM writing commands, verify that the file was written correctly.</p> <ul> <li><code>extract test</code> tests that each ROM file written has the correct size &amp; checksum</li> <li><code>zip test</code> tests that the <code>.zip</code> file has all the correct archive entry sizes &amp; checksums, and contains no excess entries</li> </ul>"},{"location":"commands/#file-manipulation","title":"File manipulation","text":""},{"location":"commands/#clean","title":"<code>clean</code>","text":"<p>Files in the output directory that do not match any ROM in any DAT will be deleted.</p>"},{"location":"commands/#rom-reporting","title":"ROM reporting","text":""},{"location":"commands/#report","title":"<code>report</code>","text":"<p>A report will be generated of what input files were matched by what DAT, and what games in what DATs have missing ROMs.</p> <p>See the reporting page for more information.</p>"},{"location":"dats/","title":"DATs","text":""},{"location":"dats/#overview","title":"Overview","text":"<p>From the RetroPie docs:</p> <p>Once you begin working with software tools to help validate, rebuild, or filter your ROM collection, you will quickly encounter the need for \"DAT\" files, so named because they usually (but not always!) have the file extension <code>.dat</code>.</p> <p>DATs describe the ROM contents including filenames, file sizes, and checksums to verify contents are not incorrect or corrupt. DATs are usually maintained either by emulator developers (such as with MAME or FinalBurn Neo) or digital preservation organizations like TOSEC and No-Intro.</p> <p>DATs are catalogs of every known ROM that exists per game system, complete with enough information to identify each file.</p> <p>These DATs help <code>igir</code> distinguish known ROM files in input directories from other files. Because DATs typically contain the complete catalog for a console, <code>igir</code> also uses them to generate reports for you on what ROMs were found and which are missing.</p> <p><code>igir</code> will look for <code>.dat</code> files automatically in your working directory, but you can specify a specific location with the <code>--dat</code> option:</p> <pre><code>igir [commands..] --dat dats/*.dat --input &lt;input&gt;\n</code></pre> <p>Or you can specify archives that can contain multiple DATs (such as No-Intro's daily download) with:</p> <pre><code>igir [commands..] --dat No-Intro*.zip --input &lt;input&gt;\n</code></pre> <p><code>igir</code> can process DAT files in XML and CMPro formats, as well as Hardware Target Game Database SMDBs that contain file sizes.</p> <p>Tip</p> <p><code>igir</code> supports URLs to DAT files and archives! This is helpful to make sure you're always using the most up-to-date version of a DAT hosted on sites such as GitHub. For example:</p> <pre><code>igir [commands..] --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/DOOM.dat\" --input &lt;input&gt;\n</code></pre> <p>Because of the way DAT-o-MATIC prepares &amp; serves downloads, you can't use this method for official No-Intro DATs.</p> <p>Info</p> <p>See the file scanning docs for more information on specify files with the <code>--dat</code> option.</p>"},{"location":"dats/#just-tell-me-what-to-do","title":"Just tell me what to do","text":"<ol> <li>Go to the No-Intro DAT-o-MATIC daily download page</li> <li>Select the \"P/C XML\" dropdown option (as opposed to \"standard DAT\") and download the <code>.zip</code> to wherever you store your ROMs</li> <li> <p>Every time you run <code>igir</code>, specify the <code>.zip</code> file you downloaded with the <code>--dat</code> option:</p> <pre><code>igir [commands..] --dat \"No-Intro*.zip\" --input &lt;input&gt;\n</code></pre> </li> </ol>"},{"location":"dats/#dat-groups","title":"DAT groups","text":"<p>A number of different release groups maintain sets of DATs, the most popular are:</p> <ul> <li>No-Intro (cartridge-based consoles)</li> <li>Redump (optical media-based consoles)</li> </ul> <p>And some less popular release groups are:</p> <ul> <li>TOSEC</li> <li>EmulationArchive (trurip)</li> <li>libretro (RetroArch):<ul> <li>Custom DATs (specific games, some optical media-based consoles)</li> <li>Mirrored DATs (No-Intro and Redump/trurip/TOSEC DATs)</li> <li>FinalBurn NEO (arcade, gen 1-4 consoles)</li> </ul> </li> <li>ADVANsCEne (GBA, DS, 3DS, PSP, PS Vita)</li> <li>progetto-SNAPS (MAME)</li> <li>pleasuredome (MAME)</li> </ul>"},{"location":"dats/#parentclone-pc-dats","title":"Parent/clone (P/C) DATs","text":"<p>DATs that include \"parent\" and \"clone\" information help <code>igir</code> understand what game releases are actually the same game (\"clones\"). Frequently a game will be released in many regions or with different revisions, usually with only language translations and minor bug fixes. For example, No-Intro has 6+ \"clones\" of Pok\u00e9mon Blue cataloged.</p> <p>Being able to know that many releases are actually the same game gives <code>igir</code> the ability to produce \"one game, one ROM\" (1G1R) sets with the <code>--single</code> option. 1G1R sets include only one of these \"clone\" releases, usually filtered to a language and region, because many people don't care about ROMs they can't understand.</p> <p>Note</p> <p>If you have the option to download \"parent/clone\" or \"P/C\" versions of DATs, you should always choose those.</p>"},{"location":"dats/#arent-dats-primarily-for-mame","title":"Aren't DATs primarily for MAME?","text":"<p>That's where DATs started. The Logiqx XML DAT format can include information in clrmamepro or Romcenter formats on how to handle MAME-specific settings such as merging (non-merged vs. merged vs. split) and packing (zip vs. not). <code>igir</code> doesn't use any of this information, but it helps paint a picture of why DATs are structured the way they are.</p> <p>These days, depending on what type of emulation you're interested in, non-MAME DATs such as No-Intro's may be more common than MAME DATs. See the DAT groups section above for some of the popular DAT release groups.</p>"},{"location":"dats/#fixdats","title":"Fixdats","text":"<p>\"Fixdats\" are DATs that contain only ROMs that are missing from your collection. Fixdats are derived from some other DAT (see above for obtaining DATs), containing only a subset of the ROMs. Fixdats are specific to the state of each person's ROM collection, so they aren't necessarily meaningful to other people.</p> <p>Fixdats help you find files missing from your collection, and they can be used to generate a collection of those files once you've found them. This sub-collection of files can then be merged back into your main collection.</p> <p>The <code>--fixdat</code> option creates a Logiqx XML DAT for every input DAT (<code>--dat</code>) that is missing ROMs. When writing (<code>copy</code>, <code>move</code>, and <code>symlink</code> commands), the fixdat will be written to the output directory, otherwise it will be written to the working directory.</p> <p>For example:</p> <pre><code>igir copy zip \\\n--dat \"Nintendo - Game Boy.dat\" \\\n--dat \"Nintendo - Game Boy Advance.dat\" \\\n--dat \"Nintendo - Game Boy Color.dat\" \\\n--input ROMs/ \\\n--output ROMs-Sorted/ \\\n--fixdat\n</code></pre> <p>may produce some fixdats in the <code>ROMs-Sorted/</code> directory, if any of the input DATs have ROMs that weren't found in the <code>ROMs/</code> input directory:</p> <pre><code>ROMs-Sorted/\n\u251c\u2500\u2500 Nintendo - Game Boy (20230414-173400) fixdat.dat\n\u251c\u2500\u2500 Nintendo - Game Boy Advance (20230414-173400) fixdat.dat\n\u2514\u2500\u2500 Nintendo - Game Boy Color (20230414-173400) fixdat.dat\n</code></pre>"},{"location":"file-scanning/","title":"File Scanning","text":"<p><code>igir</code> has a few options to specify input files, as well as files to exclude:</p> <ul> <li>ROMs: <code>--input</code> (required), <code>--input-exclude</code></li> <li>DATs: <code>--dat</code>, <code>--dat-exclude</code></li> <li>ROM patches: <code>--patch</code>, <code>--patch-exclude</code></li> </ul>"},{"location":"file-scanning/#archive-files","title":"Archive files","text":"<p><code>igir</code> can scan archives for DATs, ROMs, and patches. See the archives page for more information on supported formats.</p>"},{"location":"file-scanning/#glob-patterns","title":"Glob patterns","text":"<p>All input options support glob patterns. These patterns help you specify file paths using simple wildcards (e.g. <code>ROMs/*.rom</code>) as well as more complex patterns (e.g. <code>ROMs/!(GBA)/**/*.rom</code>).</p> <p>Tip</p> <p>globster.xyz is a great website to test various glob patterns.</p>"},{"location":"file-scanning/#examples","title":"Examples","text":"<p>Given this file tree, here are some glob pattern examples:</p> <pre><code>.\n\u251c\u2500\u2500 gb\n\u2502   \u251c\u2500\u2500 Bomberman GB (USA, Europe) (SGB Enhanced).gb\n\u2502   \u2514\u2500\u2500 [BIOS] Nintendo Game Boy Boot ROM (World) (Rev 1).gb\n\u251c\u2500\u2500 gba\n\u2502   \u2514\u2500\u2500 misc\n\u2502       \u251c\u2500\u2500 Dragon Ball Z - The Legacy of Goku II International (Japan).gba\n\u2502       \u2514\u2500\u2500 [BIOS] Game Boy Advance (World).gba\n\u2514\u2500\u2500 gbc\n    \u251c\u2500\u2500 Legend of Zelda, The - Link's Awakening DX (USA, Europe) (Rev 2) (SGB Enhanced) (GB Compatible).gbc\n    \u2514\u2500\u2500 [BIOS] Nintendo Game Boy Color Boot ROM (World) (Rev 1).gbc\n</code></pre> <p>Only process USA ROMs:</p> <pre><code>--input \"**/*USA*\"\n</code></pre> <p>Only process BIOS ROMs:</p> <pre><code>--input \"**/\\[BIOS\\]*\"\n</code></pre> <p>Only process ROMs one level deep:</p> <pre><code>--input \"*/*\"\n</code></pre> <p>Process non-GBC ROMs:</p> <pre><code>--input \"!(gbc)/**\"\n</code></pre> <p>Try some of these patterns for yourself on globster.xyz!</p>"},{"location":"installation/","title":"Installation","text":"<p>A few different installation options are offered for <code>igir</code>.</p>"},{"location":"installation/#via-nodejs","title":"Via Node.js","text":"<p>The best way to ensure that you are always running the most up-to-date version of <code>igir</code> is to run it via <code>npx</code> which comes installed with Node.js:</p> <pre><code>npx igir@latest [commands..] [options]\n</code></pre> <p>for example:</p> <pre><code>npx igir@latest copy extract --dat *.dat --input ROMs/ --output ROMs-Sorted/ --dir-dat-name\n</code></pre> <p></p> <p>Tip</p> <p>You can alias the <code>npx</code> command in your macOS or Linux dotfiles like this:</p> <pre><code>alias igir=\"npx igir@latest\"\n</code></pre>"},{"location":"installation/#via-downloaded-executable","title":"Via downloaded executable","text":"<p>If you don't want to download Node.js, you can download executables for various OSes from the GitHub releases page.</p>"},{"location":"installation/#via-docker","title":"Via Docker","text":"<p>If none of the above options work for you, Docker may be an option. You will need to mount your input and output directories as volumes, which will significantly reduce your file read and write speeds.</p> <pre><code>docker run --interactive --tty \\\n--volume \"$PWD:/pwd\" \\\n--workdir \"/pwd\" \\\nnode:lts \\\nnpx igir@latest copy zip --dat \"*.dat\" --input ROMs/ --output ROMs-Sorted/ --dir-dat-name\n</code></pre> <p>Warning</p> <p>Make sure to quote all of your file globs!</p> <p></p>"},{"location":"internals/","title":"igir Internals","text":"<p>Information about the inner workings of <code>igir</code>.</p>"},{"location":"internals/#order-of-operations","title":"Order of operations","text":"<p><code>igir</code> runs these steps in the following order:</p> <ol> <li>Scans each DAT input path for every file and parses them, if provided (<code>--dat</code>)</li> <li>Scans each ROM input path for every file (<code>--input</code>)<ul> <li>Then detects headers in those files, if applicable (see header docs)</li> </ul> </li> <li>Scans each patch input path for every file (<code>--patch</code>) (see patching docs)</li> <li>ROMs are matched to the DATs, if provided<ul> <li>Then ROMs are matched to any applicable patches, creating multiple versions from the same ROM</li> <li>Then filtering and sorting options are applied (see filtering docs)</li> <li>Then ROMs are written to the output directory, if specified (<code>copy</code>, <code>move</code>)</li> <li>Then written ROMs are tested for accuracy, if specified (<code>test</code>)</li> <li>Then input ROMs are deleted, if specified (<code>move</code>)</li> </ul> </li> <li>Unknown files are recycled from the output directory, if specified (<code>clean</code>)</li> <li>An output report is written to the output directory, if specified (<code>report</code>)</li> </ol>"},{"location":"overview/","title":"Overview","text":""},{"location":"overview/#what-is-a-rom","title":"What is a ROM?","text":"<p>From Wikipedia:</p> <p>A ROM image, or ROM file, is a computer file which contains a copy of the data from a read-only memory chip, often from a video game cartridge, or used to contain a computer's firmware, or from an arcade game's main board. The term is frequently used in the context of emulation, whereby older games or firmware are copied to ROM files on modern computers and can, using a piece of software known as an emulator, be run on a different device than which they were designed for.</p> <p>ROMs are complete copies of game data stored in cartridges or on discs.</p> <p>A game may consist of multiple ROMs. For example, arcade cabinets that contain multiple chips, or disc-based games that have multiple tracks on the disc.</p>"},{"location":"overview/#what-is-a-rom-manager","title":"What is a ROM manager?","text":"<p>ROM managers are applications that serve two main purposes:</p> <ol> <li>Help you organize your video game ROM collection</li> <li>Help you understand what video game ROMs are missing from your collection</li> </ol> <p>all additional features help serve these two purposes.</p> <p>Most ROM managers can automatically read &amp; write many different ROM types including those in archives and those with headers so that you don't have to do much pre-work.</p> <p>Most ROM managers rely on DATs, files that catalog every known ROM that exists per game system. DATs are published by release groups dedicated to keeping these catalogs accurate and up-to-date. DATs help ROM collectors name their ROMs in a consistent way as well as understand what ROMs may be missing from their collection.</p>"},{"location":"overview/#what-is-igir","title":"What is <code>igir</code>?","text":"<p><code>igir</code> is a ROM manager for the modern age.</p> <p>Most ROM managers are only built for Windows, and some offer workarounds for running on macOS and Linux. Most of these managers have confusing GUIs that make batch-able, repeatable actions difficult. <code>igir</code> is a command line tool that works on any OS.</p> <p>In addition, <code>igir</code> has features that aren't found in any other ROM managers, such as ROM patching.</p> <p>Info</p> <p>See the alternative managers page for a feature comparison between <code>igir</code> and other ROM managers.</p>"},{"location":"overview/#next-steps","title":"Next steps","text":"<p>See the installation page for instructions on getting <code>igir</code> installed.</p>"},{"location":"rom-dumping/","title":"ROM Dumping","text":"<p>Danger</p> <p>An obligatory warning about downloading ROMs:</p> <p>Emulators are generally legal, as long as they don't include copyrighted software such as a console BIOS. Downloading ROM files that you do not own is piracy which is illegal in many countries.</p> <p>Dumping.Guide and Emulation General Wiki are some of the best resources for legally creating ROM files from games you own.</p> <p>Here is a condensed version that isn't guaranteed to be up-to-date.</p>"},{"location":"rom-dumping/#generation-1-5-cartridge-based-consoles","title":"Generation 1-5 cartridge-based consoles","text":"Dumpable with special hardware Open Source Cartridge Reader(Save the Hero Builders) INLretro Dumper Retrode Other hardware Nintendo - GB, GBC, GBA \u2705 \u2705 \u2705 (w/ adapter) GB Operator Nintendo - NES/Famicom \u2705 (V3 w/ adapter) \u2705 \u274c Nintendo - Nintendo 64 \u2705 including controller pak saves (V3 w/ addon for EEPROM saves) \u2705 \u2705 including controller park saves (w/ adapter) Nintendo - SNES/SFC \u2705 (V3 w/ addon for some) \u2705 \u2705 Sega - Game Gear \u2705 (w/ Retrode Master System adapter) \u274c \u2705 (w/ Master System adapter) Sega - Genesis/MD \u2705 \u2705 \u2705 Sega - Master System \u2705 (V3 w/ adapter) \u274c \u2705 (w/ adapter)"},{"location":"rom-dumping/#generation-6-and-disk-based-consoles","title":"Generation 6+ and disk-based consoles","text":"Dumpable with software Software for native hardware Nintendo - 3DS GodMode9 Nintendo - DS, DSi GodMode9 (w/ 3DS), GodMode9i (w/ DSi), wooddumper (w/ DS) Nintendo - Famicom Disk FDSStick Nintendo - Switch nxdumptool Sony - PSP PSP Filer Sony - PlayStation Vita psvgamesd"},{"location":"rom-dumping/#optical-based-consoles","title":"Optical-based consoles","text":"Optical-based consoles Media Preservation Frontend (MPF) (w/ PC) Software for native hardware Microsoft - Xbox, 360, One \u2705 Nintendo - Gamecube \u26a0\ufe0f with specific drives and workarounds CleanRip (w/ Wii) Nintendo - Wii \u26a0\ufe0f with specific drives and workarounds CleanRip Nintendo - Wii U \u274c wudump Sega - Dreamcast \u26a0\ufe0f with specific drives and workarounds SD Rip Sega - Saturn \u2705 Sony - PlayStation 1, 2 \u2705 Sony - PlayStation 3 \u274c ManaGunZ, multiMAN"},{"location":"rom-filtering/","title":"ROM Filtering","text":"<p><code>igir</code> offers many options for filtering as well as 1G1R priority (combined with <code>--single</code>).</p> <p>They are processed in this order:</p> <ol> <li>Any filters (e.g. <code>--language-filter</code>, <code>--region-filter</code>)</li> <li>Any priorities (e.g. <code>--prefer-good</code>, <code>--prefer-revision-newer</code>)</li> <li>If <code>--single</code> is specified, only the highest priority game from a set of parent/clones (see docs) is returned</li> </ol>"},{"location":"rom-filtering/#filters","title":"Filters","text":"<p><code>igir</code> supports the following filters:</p>"},{"location":"rom-filtering/#language-filter","title":"Language filter","text":"<pre><code>--language-filter [languages..]\n</code></pre> <p>Languages are two-letter codes, and you can specify multiple languages with commas between them. See the <code>--help</code> message for the full list of understood languages.</p> <p>If a game does not have language information specified, it will be inferred from the region.</p> <p>Here are some example game names that <code>igir</code> can parse languages from, including ones with multiple languages:</p> <pre><code>English:\n  Donkey Kong (Japan, USA) (En) (SGB Enhanced)\n  Dr. Franken (USA)\n  Dragon's Lair - The Legend (Europe)\n  Gear Works (U) [!]\n\nJapanese:\n  Final Reverse (Japan)\n  Makai Toushi Sa-Ga (World) (Ja) (Rev 1) (Collection of SaGa)\n  Ohasuta Dance Dance Revolution GB (J) [C][!]\n\nSpanish:\n  Humans, The (Europe) (En,Fr,De,Es,It)\n  Pokemon - Edicion Azul (Spain) (SGB Enhanced)\n  Rugrats en Paris - La Pelicula (S) (M2) [C][!]\n</code></pre> <p>A game can have many languages, and all of them are considered during filtering.</p>"},{"location":"rom-filtering/#region-filter","title":"Region filter","text":"<pre><code>--region-filter [regions..]\n</code></pre> <p>Regions are two or three-letter codes, and you can specify multiple regions with commas between them. See the <code>--help</code> message for the full list of understood regions.</p> <p>Here are some example game names that <code>igir</code> can parse regions from:</p> <pre><code>USA:\n  10-Pin Bowling (USA)\n  Addams Family, The - Pugsley's Scavenger Hunt (USA, Europe)\n  Castelian (U) [!]\n\nJapan:\n  Dragon Quest I &amp; II (J) [C][!]\n  Taikyoku Renju (Japan) (En,Ja)\n\nEurope:\n  Adventures of Lolo (Europe) (SGB Enhanced)\n  Castlevania Adventure, The (E) [!]\n  Soccer (Europe, Australia) (En,Fr,De) (SGB Enhanced)\n\nSpain:\n  Dragon Ball Z - Guerreros de Leyenda (S) [C][!]\n  Star Trek - The Next Generation (Spain)\n</code></pre> <p>A game can only have one primary region. The first region detected is what is used.</p>"},{"location":"rom-filtering/#bios","title":"BIOS","text":"<pre><code>--no-bios, --only-bios\n</code></pre> <p>Filter out, or only include games that are marked <code>bios=\"yes\"</code> in the DAT, or contain <code>[BIOS]</code> in their name, e.g.:</p> <pre><code>[BIOS] Nintendo Game Boy Boot ROM (World) (Rev 1)\n[BIOS] Nintendo Game Boy Color Boot ROM (World) (Rev 1)\n</code></pre> <p>Tip</p> <p><code>--only-bios</code> is a great option to collate all BIOS files across all consoles to one directory.</p>"},{"location":"rom-filtering/#mame-devices","title":"MAME devices","text":"<pre><code>--no-device, --only-device\n</code></pre> <p>Filter out, or only include MAME devices. MAME devices typically represent physical devices, such as microcontrollers, video display controllers, sounds boards, and more. Many MAME devices don't have any associated ROM files.</p>"},{"location":"rom-filtering/#unlicensed","title":"Unlicensed","text":"<pre><code>--no-unlicensed, --only-unlicensed\n</code></pre> <p>Filter out, or only include games that contain <code>(Unl)</code> or <code>(Unlicensed)</code> in their name, e.g.:</p> <pre><code>4 in 1 (Europe) (4B-002, Sachen) (Unl)\nCaihong Zhanshi - Rainbow Prince (Taiwan) (Unl)\n</code></pre> <p>These games are still considered \"retail\" releases (below).</p>"},{"location":"rom-filtering/#only-retail","title":"Only retail","text":"<pre><code>--only-retail\n</code></pre> <p>Enables all the following <code>--no-*</code> options, as well as filtering out games that are:</p> <ul> <li> <p>Alphas: games that contain <code>(Alpha)</code> in their name, e.g.:</p> <pre><code>Isle Quest (World) (v0.1c) (Alpha) (Aftermarket) (Homebrew)\nSword (Alpha) (PD) [C]\n</code></pre> </li> </ul> <ul> <li> <p>Fixed: games that contain <code>[f]</code> or <code>[f#]</code> in their name, e.g.:</p> <pre><code>Black Bass - Lure Fishing (U) [C][f1]\nBugs Bunny - Crazy Castle 3 (J) [C][f2]\n</code></pre> </li> </ul> <ul> <li> <p>Non-public \"MIA\": games that contain <code>[MIA]</code> in their name, e.g.:</p> <pre><code>[MIA] Better Dead Than Alien (Europe)\n[MIA] Billiards Simulator (Europe) (En,Fr,De)\n</code></pre> </li> </ul> <ul> <li> <p>Overdumps: games that contain <code>[o]</code> or <code>[o#]</code> in their name, e.g.:</p> <pre><code>Castlevania II - Belmont's Revenge (U) [o1]\nCave Noire (J) [o2]\n</code></pre> </li> </ul> <ul> <li> <p>Pending dumps: games that contain <code>[!p]</code> in their name, e.g.:</p> <pre><code>Cheetah Men II (Active Enterprises) [!p]\n</code></pre> </li> </ul> <ul> <li> <p>Pirated: games that contain <code>(Pirate)</code>, <code>[p]</code>, or <code>[p#]</code> in their name, e.g.:</p> <pre><code>Flipull (J) [p1]\nSuper Mario 4 (Unknown) (Ja) (Pirate)\nSuper Robot Taisen Final Vol.1 (Unl) [C][p2]\n</code></pre> </li> </ul> <ul> <li> <p>Unofficial translations: games that contain <code>[T-*]</code> or <code>[T+*]</code> in their name, e.g.:</p> <pre><code>Duck Tales (E) [T-Ger]\nFinal Fantasy Legend II (U) [T+Fre]\n</code></pre> </li> </ul> <ul> <li> <p>Games with hacks: games that contain <code>(Hack)</code> or <code>[h*]</code> in their name, e.g.:</p> <pre><code>Kirby's Dream Land 2 (U) [S][h1] (Sound Test)\nPokemon - Blue Version (UE) [S][h2]\nQ-bert II (UE) [h1C]\n</code></pre> </li> </ul> <ul> <li> <p>Games with trainers: games that contain <code>[t]</code> or <code>[t#]</code> in their name, e.g.:</p> <pre><code>Qix Adventure (J) [C][t1]\nR-Type DX (U) [C][t2]\n</code></pre> </li> </ul>"},{"location":"rom-filtering/#demos","title":"Demos","text":"<pre><code>--no-demo, --only-demo\n</code></pre> <p>Filter out, or only include games that contain <code>(Demo)</code> in their name, e.g.:</p> <pre><code>Coria and the Sunken City (Unknown) (Demo)\nTwo Hearts (Japan) (Demo) (Unl)\n</code></pre>"},{"location":"rom-filtering/#betas","title":"Betas","text":"<pre><code>--no-beta, --only-beta\n</code></pre> <p>Filter out, or only include games that contain <code>(Beta)</code> in their name, e.g.:</p> <pre><code>Cosmo Tank (Japan) (Beta)\nF-15 Strike Eagle II (USA, Europe) (Beta) (July, 1992)\n</code></pre>"},{"location":"rom-filtering/#samples","title":"Samples","text":"<pre><code>--no-sample, --only-sample\n</code></pre> <p>Filter out, or only include games that contain <code>(Sample)</code> in their name, e.g.:</p> <pre><code>Mega Man III (USA) (Sample)\nShin Nihon Pro Wrestling - Toukon Sanjuushi (Japan) (Sample)\n</code></pre>"},{"location":"rom-filtering/#prototypes","title":"Prototypes","text":"<pre><code>--no-prototype, --only-prototype\n</code></pre> <p>Filter out, or only include games that contain <code>(Proto)</code> or <code>(Prototype)</code> in their name, e.g.:</p> <pre><code>Philip &amp; Marlowe in Bloomland (USA) (Proto)\nSword of Hope, The (Europe) (Proto)\n</code></pre>"},{"location":"rom-filtering/#test-roms","title":"Test ROMs","text":"<pre><code>--no-test-roms, --only-test-roms\n</code></pre> <p>Filter out, or only include games that contain <code>(Test)</code> in their name, e.g.:</p> <pre><code>2097 ROM Pack II (USA) (Test Program)\nGame Boy Test Cartridge (USA, Europe) (Proto) (Test Program)\n</code></pre>"},{"location":"rom-filtering/#homebrew","title":"Homebrew","text":"<pre><code>--no-homebrew, --only-homebrew\n</code></pre> <p>Filter out, or only include games that contain <code>(Homebrew)</code> in their name, e.g.:</p> <pre><code>Game Boy Camera Gallery 2022, The (World) (Aftermarket) (Homebrew)\nGB-Wordyl (World) (Aftermarket) (Homebrew)\n</code></pre>"},{"location":"rom-filtering/#unverified-dumps","title":"Unverified dumps","text":"<pre><code>--no-unverified, --only-unverified\n</code></pre> <p>Filter out, or only include games that do not contain <code>[!]</code> in their name, e.g.:</p> <pre><code>Getaway, The (U)\nGex - Enter the Gecko (U) [C][b1]\nGolf (W) [o1]\nGrand Theft Auto (E) (M5) [C][t1]\n</code></pre> <p>Warning</p> <p>This is a GoodTools naming convention, other groups such as No-Intro never include <code>[!]</code> in their names!</p>"},{"location":"rom-filtering/#bad-dumps","title":"Bad dumps","text":"<pre><code>--no-bad, --only-bad\n</code></pre> <p>Filter out, or only include games that contain <code>[b]</code> or <code>[b#]</code> in their name, e.g.:</p> <pre><code>[MIA] Aprilia - DiTech Interface (Unknown) (Unl) [b]\nGreat Greed (U) [b1]\nGremlins 2 - The New Batch (W) [b2]\n</code></pre> <p>as well as games that contain <code>[c]</code> or <code>[x]</code> and are not verified dumps (above), e.g.:</p> <pre><code>Brian Lara Cricket 96 (E) [a1][x]\nMicro Machines Military - It's a Blast! (E) [x]\n</code></pre>"},{"location":"rom-headers/","title":"ROM Headers","text":"<p>There are a handful of consoles where it is common for their ROMs to have extra data at the beginning of the file (a \"header\") that wasn't present on the physical ROM chip.</p> <p>Some of these headers are used to tell the emulator information about how to emulate the game (Atari 7800 \"A78\", NES \"iNES\", Famicom Disk System \"FDS\", etc.). There are other consoles where it is somewhat common to find the ROMs without a header (Atari Lynx \"LYX\", SNES \"SFC\").</p>"},{"location":"rom-headers/#header-detection","title":"Header detection","text":"<p><code>igir</code> can detect headers for the following consoles and file extensions:</p> Console Header Extension Atari 7800 A78 <code>.a78</code> Atari Lynx LNX <code>.lnx</code> Nintendo - NES iNES, NES 2.0 <code>.nes</code> Nintendo - Famicom Disk System fsNES/FDS <code>.fds</code> Nintendo - SNES SMC <code>.smc</code> <p>Those file extensions above are the commonly accepted \"correct\" ones and <code>igir</code> will attempt to detect if a header is present in them automatically. If for some reason your files don't have the right extension (e.g. <code>.rom</code>) you can force header detection with the <code>--header</code> glob option:</p> <pre><code>igir [commands..] --dat &lt;dats&gt; --input &lt;input&gt; --header \"*.rom\"\n</code></pre> <p><code>igir</code> will use this detected header information to compute both \"headered\" and \"un-headered\" checksums of ROMs and use both of those to match against DAT files. Many DAT groups expressly only include the size and checksum information for the un-headered file, even if the header should not be removed.</p>"},{"location":"rom-headers/#manual-header-removal","title":"Manual header removal","text":"<p>Some emulators cannot parse ROMs with headers and instead need an \"un-headered\" version. This seems to be most common with SNES. Sometimes \"un-headered\" files will have a different file extension:</p> Console Header HeaderedExtension Un-headeredExtension Atari 7800 A78 <code>.a78</code> N/A Atari Lynx LNX <code>.lnx</code> <code>.lyx</code> Nintendo - NES iNES, NES 2.0 <code>.nes</code> N/A Nintendo - Famicom Disk System fsNES/FDS <code>.fds</code> N/A Nintendo - SNES SMC <code>.smc</code> <code>.sfc</code> <p>For every console that <code>igir</code> can understand the headers for, it can also remove them with the <code>--remove-headers</code> option. This only makes sense for the consoles above with different \"un-headered\" extensions, so you have to specify the extensions like this:</p> <pre><code>igir [commands..] --dat &lt;dats&gt; --input &lt;input&gt; --remove-headers .lnx,.smc\n</code></pre> <p>But if you're absolutely sure you want to remove any known header from every single ROM file, you can omit the extension argument:</p> <pre><code>igir [commands..] --dat &lt;dats&gt; --input &lt;input&gt; --remove-headers\n</code></pre>"},{"location":"rom-headers/#automatic-header-removal","title":"Automatic header removal","text":"<p>Some DAT groups such as No-Intro publish \"headered\" and \"headerless\" DATs for the same console, such as NES. <code>igir</code> will treat these DATs differently, automatically removing headers (if present) for \"headerless\" DATs, and leaving the header intact for \"headered\" DATs (regardless of CLI parameters).</p> <p>As explained above, you almost always want the \"headered\" version. It's only in very specific circumstances that you might need the \"headerless\" version.</p>"},{"location":"rom-patching/","title":"ROM Patching","text":"<p>Patches contain a set of changes that can be applied to a file, turning that file into something different. Common examples for patching ROMs are: translating text to a different language but keeping game logic the same, and fan-made creations such as new levels for an existing game.</p> <p>Games and their ROMs are protected under copyrights, so patches are used in order to not share copyrighted code online. A person needs the original ROM file plus a patch file in order to get the resulting patched ROM that will be played with an emulator.</p>"},{"location":"rom-patching/#specifying-patch-files","title":"Specifying patch files","text":"<p>Patch files can be specified with the <code>--patch</code> option. See the file scanning docs for more information.</p>"},{"location":"rom-patching/#patch-types","title":"Patch types","text":"<p>There are many, many patch types that ROM hackers use to distribute their changes on the internet (xkcd \"Standards\"). Typically, a patch will only be distributed in one format, so gamers are entirely at the mercy of the ROM hacker's choice.</p> <p>Not all patch types are created equal. Here are some tables of some existing formats, whether <code>igir</code> supports them, and what the patch supports.</p> <p>Common patch types:</p> Type Supported CRC32 in patch contents Notes <code>.bps</code> \u2705 \u2705 <code>.ips</code> \u2705 IPS, IPS32 \u274c <code>.ppf</code> \u2705 2.0, 3.0 \u274c <code>.ups</code> \u2705 \u2705 \u26a0\ufe0f UPS patches read and write fies byte-by-byte, making them horribly slow and inefficient. The author, byuu, created <code>.ups</code> to replace <code>.ips</code>, but then created <code>.bps</code> as a replacement for <code>.ups</code>. <code>.vcdiff</code>, <code>.xdelta</code> \u26a0\ufe0f without secondary compression \u274c \u26a0\ufe0f xdelta3 makes use of LZMA secondary compression by default, so many patches are likely to be unsupported. <p>Uncommon patch types:</p> Type Supported CRC32 in patch contents Notes <code>.aps</code> (GBA) \u2705 \u274c <code>.aps</code> (N64) \u2705 simple &amp; N64 \u274c <code>.bdf</code> (BSDiff) \u274c \u2753 <code>.bsp</code> (Binary Script Patching) \u274c \u274c BSP will probably never be supported, the implementation is non-trivial. <code>.dldi</code> (NDS libfat) \u274c \u274c No file specification exists. <code>.dps</code> (Deufeufeu) \u2705 \u274c <code>.ebp</code> (EarthBound) \u2705 \u274c EBP is just IPS with some JSON after the <code>EOF</code> string. <code>.gdiff</code> \u274c \u2753 <code>.mod</code> (Star Rod) \u274c \u2753 No file specification exists anymore. <code>.ffp</code>, <code>.pat</code> (FireFlower) \u274c \u2753 No file specification exists anymore. <code>.pds</code> (Sephiroth87's NDS) \u274c \u2753 No file specification exists. <code>.rup</code> (NINJA 2.0) \u26a0\ufe0f only single file patches, only raw/binary file type \u274c uses MD5 <code>.rxl</code> (ROM eXtension Library) \u274c \u274c RXL will probably never be supported, it is used to inject files at manually specified locations into ROMs. <p>If you have a choice in patch format, choose one that contains CRC32 checksums in the patch file contents.</p>"},{"location":"rom-patching/#rom-checksums","title":"ROM checksums","text":"<p><code>igir</code> needs to be able to know what source ROM each patch file applies to, and it does this using CRC32 checksums.</p> <p>A few patch formats include the source ROM's CRC32 checksum in the patch's file contents. This is the most accurate and therefore the best way to get source ROM information. <code>.bps</code> is a great example of an efficient and simple patch format that includes this information.</p> <p>Most patch formats do not include the source ROM's CRC32 checksum. <code>.ips</code> patches are some of the most likely you will come across. For those patches, you need to put the source ROM's CRC32 checksum in the patch's filename, either at the beginning or end, like this:</p> <pre><code>Source ROM filename:\nSuper Mario Land (World).gb\n\nPatch filename:\nSuper Mario Land DX v2.0 (World) 90776841.ips\n</code></pre> <pre><code>Source ROM filename:\nNBA Jam - Tournament Edition (USA) (Track 1).bin\n\nPatch filename:\na8f1adf5 NBA Jam 22 v1.4.ppf\n</code></pre>"},{"location":"rom-patching/#creating-rom-patches","title":"Creating ROM patches","text":"<p>Marc Robledo's Rom Patcher JS site is a great resource for creating ROM patches in a number of common formats without the need to download any tools.</p>"},{"location":"output/reporting/","title":"Reporting","text":""},{"location":"output/reporting/#overview","title":"Overview","text":"<p>When using DATs (the <code>--dat</code> option), the <code>igir report</code> command can report on:</p> <ul> <li>What ROMs were found, and where the files are</li> <li>What ROMs are missing</li> <li>What input files didn't match to any ROM</li> <li>What output files were cleaned (<code>igir clean</code> command)</li> </ul> <p>At least one DAT is required for the <code>igir report</code> command to work, otherwise <code>igir</code> has no way to understand what input files are known ROMs and which aren't. See the DAT docs for more information about DATs.</p> <p>The <code>igir report</code> can be specified on its own without any writing command in order to report on an existing collection, e.g.:</p> <pre><code>$ igir report --dat *.dat --input ROMs/\n\n$ ls ROMs/*.csv\nROMs/igir_2023-03-29T18;26;00-04;00.csv\n</code></pre>"},{"location":"output/reporting/#format-filtering","title":"Format &amp; filtering","text":"<p>The output report format is a standard CSV which can be opened in Microsoft Excel, Apple Numbers, Google Sheets, LibreOffice Calc, and similar spreadsheet applications.</p> <p>Unlike the report formats of other tools, CSVs allow you to filter rows by column values. For example, you can filter the \"Status\" column to only \"MISSING\" to understand what ROMs are missing from your collection, or to \"UNMATCHED\" to understand what input files aren't recognized as a known ROM. The ability to filter CSVs in spreadsheet applications means that <code>igir</code> should not need use-case-specific options to achieve your goal.</p> <p>To perform this filtering, most spreadsheet applications have a button or menu item to \"create a filter\" or \"auto filter.\"</p>"},{"location":"output/reporting/#output-location","title":"Output location","text":"<p>The <code>--report-output</code> options is provided to configure where the <code>igir report</code> report is written. See the <code>igir --help</code> message for the report's default location.</p> <p>The report output filename supports a version of Moment.js symbols for date and time. To make it clearer what is a replaceable symbol, <code>%</code> is prepended to symbols. This is non-standard for Moment.js - but the <code>%</code> format should feel more familiar to more people as it resembles Python's <code>date.strftime()</code>, PHP's <code>strftime()</code>, C++'s <code>strftime()</code>, and more.</p> <p>Info</p> <p>See the Moment.js docs for a complete list of tokens you can use.</p> <p>Here are some example usages:</p> <pre><code>$ igir report --dat *.dat --input ROMs/ --report-output \"./report.csv\"\n$ igir report --dat *.dat --input ROMs/ --report-output \"./report %dddd, %MMMM %Do %YYYY, %h:%mm:%ss %a.csv\"\n# ./report Friday, April 14th 2023, 4:28:26 pm.csv\n$ igir report --dat *.dat --input ROMs/ --report-output \"/igir/%X.csv\"\n# /igir/1681515048.csv\n</code></pre>"},{"location":"output/tokens/","title":"Output Tokens","text":"<p>When specifying a ROM writing command you have to specify an <code>--output</code> directory. <code>igir</code> has a few replaceable \"tokens\" that can be referenced in the <code>--output</code> directory value. This can aid in sorting ROMs into a more complicated directory structure.</p> <p>For example, if you want to group all ROMs based on their region, you would specify:</p> WindowsmacOS <pre><code>igir.exe copy extract --dat *.dat --input ROMs/ --output \"ROMs-Sorted/{datReleaseRegion}/\"\n</code></pre> <pre><code>igir copy extract --dat *.dat --input ROMs/ --output \"ROMs-Sorted/{datReleaseRegion}/\"\n</code></pre> <p>This might result in an output structure such as:</p> <pre><code>ROMs-Sorted/\n\u251c\u2500\u2500 AUS\n\u2502   \u2514\u2500\u2500 Pokemon Pinball (USA, Australia) (Rumble Version) (SGB Enhanced) (GB Compatible).gbc\n\u251c\u2500\u2500 EUR\n\u2502   \u251c\u2500\u2500 Pokemon - Blue Version (USA, Europe) (SGB Enhanced).gb\n\u2502   \u251c\u2500\u2500 Pokemon - Red Version (USA, Europe) (SGB Enhanced).gb\n\u2502   \u2514\u2500\u2500 Pokemon - Yellow Version - Special Pikachu Edition (USA, Europe) (CGB+SGB Enhanced).gb\n\u2514\u2500\u2500 USA\n    \u251c\u2500\u2500 Pokemon - Blue Version (USA, Europe) (SGB Enhanced).gb\n    \u251c\u2500\u2500 Pokemon - Red Version (USA, Europe) (SGB Enhanced).gb\n    \u251c\u2500\u2500 Pokemon - Yellow Version - Special Pikachu Edition (USA, Europe) (CGB+SGB Enhanced).gb\n    \u2514\u2500\u2500 Pokemon Pinball (USA, Australia) (Rumble Version) (SGB Enhanced) (GB Compatible).gbc\n</code></pre> <p>Note</p> <p>Tokens can resolve to multiple values for each ROM. For example, a ROM may have multiple regions or languages. This will result in the same ROM being written to multiple locations.</p>"},{"location":"output/tokens/#dat-information","title":"DAT information","text":"<p>When using DATs, you can make use of console &amp; game information contained in them:</p> <ul> <li><code>{datName}</code> the matching DAT's name, similar to how the <code>--dir-dat-name</code> option works</li> <li><code>{datReleaseLanguage}</code> each of the ROM's language(s) (e.g. <code>EN</code>, <code>ES</code>, <code>JA</code>)</li> <li><code>{datReleaseRegion}</code> each of the ROM's region(s) (e.g. <code>USA</code>, <code>EUR</code>, <code>JPN</code>, <code>WORLD</code>)</li> </ul>"},{"location":"output/tokens/#file-information","title":"File information","text":"<p>You can use some information about the input and output file's name &amp; location:</p> <ul> <li><code>{inputDirname}</code> the input file's dirname (full path minus file basename)</li> <li><code>{outputBasename}</code> the output file's basename, equivalent to <code>{outputName}.{outputExt}</code></li> <li><code>{outputName}</code> the output file's filename without its extension</li> <li><code>{outputExt}</code> the output file's extension</li> </ul>"},{"location":"output/tokens/#specific-hardware","title":"Specific hardware","text":"<p>To help sort ROMs into unique file structures for popular frontends &amp; hardware, <code>igir</code> offers a few specific tokens:</p> <ul> <li><code>{pocket}</code> the Analogue Pocket core's directory for the ROM</li> <li><code>{mister}</code> the MiSTer FPGA core's directory for the ROM</li> <li><code>{onion}</code> the OnionOS / GarlicOS emulator's directory for the ROM</li> </ul> <p>Tip</p> <p>See the <code>igir --help</code> message for the list of all replaceable tokens.</p>"},{"location":"usage/collection-sorting/","title":"Collection Sorting","text":"<p>A walkthrough of an example way to sort your ROM collection.</p> <p>Info</p> <p>See the <code>igir --help</code> message for a few common examples.</p>"},{"location":"usage/collection-sorting/#first-time-collection-sort","title":"First time collection sort","text":"<p>First, you need to download a set of DATs. For these examples I'll assume you downloaded a No-Intro daily P/C XML <code>.zip</code>.</p> <p>Let's say that you have a directory named <code>ROMs/</code> that contains ROMs for many different systems, and it needs some organization. To make sure we're alright with the output, we'll have <code>igir</code> copy these files rather than move them. We'll also zip them to reduce disk space &amp; speed up future scans.</p> WindowsmacOS <pre><code>igir.exe copy zip test ^\n --dat \"No-Intro*.zip\" ^\n --input ROMs/ ^\n --output ROMs-Sorted/ ^\n --dir-dat-name\n</code></pre> <pre><code>igir copy zip test \\\n--dat \"No-Intro*.zip\" \\\n--input ROMs/ \\\n--output ROMs-Sorted/ \\\n--dir-dat-name\n</code></pre> <p>This will organize your ROMs into system-specific subdirectories within <code>ROMs-Sorted/</code> and name all of your ROMs accurately. Because we copied and didn't move, no files were deleted from the <code>ROMs/</code> input directory.</p> <p><code>ROMs-Sorted/</code> then might look something like this:</p> <pre><code>ROMs-Sorted\n\u251c\u2500\u2500 Nintendo - Game Boy\n\u2502   \u251c\u2500\u2500 Pokemon - Blue Version (USA, Europe) (SGB Enhanced).zip\n\u2502   \u2514\u2500\u2500 Pokemon - Yellow Version - Special Pikachu Edition (USA, Europe) (CGB+SGB Enhanced).zip\n\u251c\u2500\u2500 Nintendo - Game Boy Advance\n\u2502   \u251c\u2500\u2500 Pokemon - Emerald Version (USA, Europe).zip\n\u2502   \u2514\u2500\u2500 Pokemon - Sapphire Version (USA, Europe) (Rev 2).zip\n\u2514\u2500\u2500 Nintendo - Game Boy Color\n    \u251c\u2500\u2500 Pokemon - Crystal Version (USA, Europe) (Rev 1).zip\n    \u2514\u2500\u2500 Pokemon Pinball (USA, Australia) (Rumble Version) (SGB Enhanced) (GB Compatible).zip\n</code></pre> <p></p>"},{"location":"usage/collection-sorting/#subsequent-collection-sorts","title":"Subsequent collection sorts","text":"<p>Let's say that we've done the above first time sort and were happy with the results. We can now consider the <code>ROMs-Sorted/</code> directory to be our primary collection, every file in there has been matched to a DAT.</p> <p>Now we have new ROMs that we want to merge into our collection, and we want to generate a report of what ROMs are still missing. We also want to delete any unknown files that may have made their way into our collection.</p> WindowsmacOS <pre><code>igir.exe move zip test clean report ^\n --dat \"No-Intro*.zip\" ^\n --input ROMs-New/ ^\n --input ROMs-Sorted/ ^\n --output ROMs-Sorted/ ^\n --dir-dat-name\n</code></pre> <pre><code>igir move zip test clean report \\\n--dat \"No-Intro*.zip\" \\\n--input ROMs-New/ \\\n--input ROMs-Sorted/ \\\n--output ROMs-Sorted/ \\\n--dir-dat-name\n</code></pre> <p>Any new ROMs in <code>~/Downloads/</code> that we didn't already have in <code>ROMs-Sorted/</code> will be moved, and a report will be generated for us.</p> <p><code>ROMs-Sorted/</code> then might look something like this, with new ROMs added:</p> <pre><code>ROMs-Sorted\n\u251c\u2500\u2500 Nintendo - Game Boy\n\u2502   \u251c\u2500\u2500 Pokemon - Blue Version (USA, Europe) (SGB Enhanced).zip\n\u2502   \u251c\u2500\u2500 Pokemon - Red Version (USA, Europe) (SGB Enhanced).zip\n\u2502   \u2514\u2500\u2500 Pokemon - Yellow Version - Special Pikachu Edition (USA, Europe) (CGB+SGB Enhanced).zip\n\u251c\u2500\u2500 Nintendo - Game Boy Advance\n\u2502   \u251c\u2500\u2500 Pokemon - Emerald Version (USA, Europe).zip\n\u2502   \u251c\u2500\u2500 Pokemon - Ruby Version (USA, Europe) (Rev 2).zip\n\u2502   \u2514\u2500\u2500 Pokemon - Sapphire Version (USA, Europe) (Rev 2).zip\n\u2514\u2500\u2500 Nintendo - Game Boy Color\n    \u251c\u2500\u2500 Pokemon - Crystal Version (USA, Europe) (Rev 1).zip\n    \u2514\u2500\u2500 Pokemon Pinball (USA, Australia) (Rumble Version) (SGB Enhanced) (GB Compatible).zip\n</code></pre> <p></p>"},{"location":"usage/collection-sorting/#flash-cart-1g1r","title":"Flash cart 1G1R","text":"<p>Let's say we've done the above sorting we want to copy some ROMs from <code>ROMs-Sorted/</code> to a flash cart.</p> <p>We would prefer having only one copy of every game (1G1R), so there is less to scroll through to find what we want, and because we have a preferred language. Our flash cart can't read <code>.zip</code> files, so we'll need to extract our ROMs during copying.</p> WindowsmacOS <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir.exe copy extract test clean ^\n --dat \"No-Intro*.zip\" ^\n --input \"ROMs-Sorted/Nintendo - Game Boy\" ^\n --output E:\\ ^\n --dir-letter ^\n --no-bios ^\n --single ^\n --prefer-language EN ^\n --prefer-region USA,WORLD,EUR,JPN\n</code></pre> <p>Replace the <code>/Volumes/FlashCart</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy extract test clean \\\n--dat \"No-Intro*.zip\" \\\n--input \"ROMs-Sorted/Nintendo - Game Boy\" \\\n--output /Volumes/FlashCart/ \\\n--dir-letter \\\n--no-bios \\\n--single \\\n--prefer-language EN \\\n--prefer-region USA,WORLD,EUR,JPN\n</code></pre> <p>Your flash cart might then look something like this:</p> <pre><code>/Volumes/FlashCart\n\u2514\u2500\u2500 P\n    \u251c\u2500\u2500 Pokemon - Blue Version (USA, Europe) (SGB Enhanced).gb\n    \u251c\u2500\u2500 Pokemon - Red Version (USA, Europe) (SGB Enhanced).gb\n    \u2514\u2500\u2500 Pokemon - Yellow Version - Special Pikachu Edition (USA, Europe) (CGB+SGB Enhanced).gb\n</code></pre> <p></p> <p>Info</p> <p>See the ROM filtering page for other ways that you can filter your collection.</p>"},{"location":"usage/personal/","title":"Personal Usage","text":"<p><code>igir</code> has many options available to fit almost any use case, but the number of options can be overwhelming. So that begs a question: how do I, the author of <code>igir</code>, use <code>igir</code> in the real world?</p>"},{"location":"usage/personal/#primary-rom-library","title":"Primary ROM library","text":"<p>I have a 4TiB external hard drive that I use as my source of truth where I store all of my DATs, ROMs, and patches. In general, I'm more interested in cartridge-based consoles. Optical-based ROMs can take up a significant amount of space.</p> <p>The file tree in that hard drive looks like this:</p> <pre><code>/Volumes/WDPassport4\n\u251c\u2500\u2500 FBNeo\n\u2502   \u251c\u2500\u2500 Arcade\n\u2502   \u2514\u2500\u2500 Neogeo\n\u251c\u2500\u2500 No-Intro\n\u2502   \u251c\u2500\u2500 Nintendo - Game Boy\n\u2502   \u251c\u2500\u2500 Nintendo - Game Boy Advance\n\u2502   \u251c\u2500\u2500 Nintendo - Game Boy Advance (Multiboot)\n\u2502   \u251c\u2500\u2500 Nintendo - Game Boy Advance (Video)\n\u2502   \u251c\u2500\u2500 Nintendo - Game Boy Advance (e-Reader)\n\u2502   \u251c\u2500\u2500 Nintendo - Game Boy Color\n\u2502   \u2514\u2500\u2500 etc...\n\u251c\u2500\u2500 No-Intro Love Pack (PC XML) (2023-01-29).zip\n\u251c\u2500\u2500 Patches\n\u2502   \u251c\u2500\u2500 gb\n\u2502   \u251c\u2500\u2500 gba\n\u2502   \u251c\u2500\u2500 gbc\n\u2502   \u251c\u2500\u2500 genesis\n\u2502   \u2514\u2500\u2500 snes\n\u251c\u2500\u2500 Redump\n\u2502   \u251c\u2500\u2500 Microsoft - Xbox - BIOS Images\n\u2502   \u251c\u2500\u2500 Nintendo - GameCube\n\u2502   \u251c\u2500\u2500 Sony - PlayStation - BIOS Images\n\u2502   \u2514\u2500\u2500 Sony - PlayStation 2 - BIOS Images\n\u251c\u2500\u2500 Redump (2023-01-29).zip\n\u251c\u2500\u2500 TOSEC - DAT Pack - Complete (3530) (TOSEC-v2022-07-10).zip\n\u2514\u2500\u2500 igir_library_sync.sh\n</code></pre> <p>The root directory has a DAT zip and subdirectory for each DAT release group. This helps separate differing quality of DATs and different DAT group ROM naming schemes. I then have one subdirectory for each game console, using the <code>--dir-dat-name</code> option.</p> <p>The <code>igir_library_sync.sh</code> script helps me keep this collection organized and merge new ROMs into it. The complete source is:</p> <pre><code>#!/usr/bin/env bash\n# @param {...string} $@ Input directories to merge into this collection\nset -euo pipefail\n\n# Treat every CLI argument as an input directory\nINPUTS=()\nfor INPUT in \"$@\"; do\nINPUTS+=(--input \"${INPUT}\")\ndone\nnpx --yes igir@latest move zip test clean report \\\n--dat \"./No-Intro*.zip\" \\\n--input \"./No-Intro/\" \\\n\"${INPUTS[@]}\" \\\n--patch \"./Patches/\" \\\n--output \"./No-Intro/\" \\\n--dir-dat-name\n\nnpx --yes igir@latest move extract test report \\\n--dat \"./Redump*.zip\" \\\n--input \"./Redump/\" \\\n\"${INPUTS[@]}\" \\\n--output \"./Redump/\" \\\n--dir-dat-name\n</code></pre> <p>I then copy ROMs to other devices from this source of truth.</p>"},{"location":"usage/personal/#analogue-pocket","title":"Analogue Pocket","text":"<p>Note</p> <p>See the full Analogue Pocket page for more detailed information.</p> <p>I have this script <code>igir_pocket_sync.sh</code> at the root of my Analogue Pocket's SD card:</p> <pre><code>#!/usr/bin/env bash\nset -euo pipefail\n\nSOURCE=/Volumes/WDPassport4\n\nnpx igir@latest copy extract test clean \\\n--dat \"${SOURCE}/No-Intro*.zip\" \\\n--input \"${SOURCE}/No-Intro/\" \\\n--input-exclude \"${SOURCE}/No-Intro/Nintendo - Game Boy Advance (e-Reader)/\" \\\n--patch \"${SOURCE}/Patches/\" \\\n--output \"./Assets/{pocket}/common/\" \\\n--dir-letter \\\n`# Leave BIOS files alone` \\\n--clean-exclude \"./Assets/*/common/*.*\" \\\n--no-bios \\\n--no-bad \\\n--single \\\n--prefer-language EN \\\n--prefer-region USA,WORLD,EUR,JPN \\\n--prefer-revision-newer \\\n--prefer-retail\n</code></pre> <p>That lets me create an EN+USA preferred 1G1R set for my Pocket on the fly, making sure I don't delete BIOS files needed for each core.</p>"},{"location":"usage/personal/#gamecube","title":"GameCube","text":"<p>I have this script <code>sd2sp2_pocket_sync.sh</code> at the root of my GameCube SD2SP2 SD card:</p> <pre><code>#!/usr/bin/env bash\nset -euo pipefail\n\nSOURCE=/Volumes/WDPassport4\n\nnpx --yes igir@latest copy extract test clean \\\n--input \"${SOURCE}/Redump/Nintendo - GameCube\" \\\n--output \"./ISOs/\" \\\n--dir-letter \\\n--no-bios \\\n--only-retail \\\n--filter-regex-exclude \"/(Baseball|Cabela|F1|FIFA|Football|Golf|Madden|MLB|NASCAR|NBA|NCAA|NFL|NHL|PGA|Soccer|Tennis|UFC|WWE)/i\" \\\n--writer-threads 1\n</code></pre> <p>It doesn't use DATs because I have the ISOs in a trimmed NKit format (see Swiss), so they won't match the checksums in DATs. I also exclude some games due to limited SD card size.</p> <p>Note</p> <p>This uses the <code>--writer-threads</code> debug option because Swiss is sensitive to files being fragmented on the SD card (swiss-gc#763, swiss-gc#122, etc.). From experience, if you write too many files to an SD card at once, you may get an ambiguous error message mentioning fragmentation when loading an ISO.</p>"},{"location":"usage/desktop/batocera/","title":"Batocera","text":"<p>Batocera is a pre-configured Linux OS image for EmulationStation.</p>"},{"location":"usage/desktop/batocera/#bios","title":"BIOS","text":""},{"location":"usage/desktop/batocera/#roms","title":"ROMs","text":""},{"location":"usage/desktop/emulationstation/","title":"EmulationStation","text":""},{"location":"usage/desktop/emulationstation/#emulationstation-desktop-edition-es-de","title":"EmulationStation Desktop Edition (ES-DE)","text":"<p>EmulationStation Desktop Edition is a frontend for RetroArch, so the instructions are the same as RetroArch.</p>"},{"location":"usage/desktop/lakka/","title":"Lakka","text":""},{"location":"usage/desktop/recalbox/","title":"Recalbox","text":""},{"location":"usage/desktop/retroarch/","title":"RetroArch","text":"<p>RetroArch is a frontend UI for the Libretro API.</p> <p>Note</p> <p>RetroArch is available for a number of devices, including smartphones and consoles. These instructions will only work on desktop OSes, but once your files are organized you can copy them over to your other device.</p>"},{"location":"usage/desktop/retroarch/#bios","title":"BIOS","text":"<p>First, RetroArch needs a number of BIOS files. Thankfully, the libretro team maintains a DAT of these \"system\" files, so we don't have to guess at the correct filenames.</p> <p>With <code>igir</code>'s support for DAT URLs we don't even have to download the DAT! Locate your \"System/BIOS\" directory as configured in the RetroArch UI and use it as your output directory:</p> Windows (64-bit)Windows (32-bit)macOS <p>The root directory is based on where you installed RetroArch, but by default it is:</p> <pre><code>igir.exe copy extract test clean ^\n --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" ^\n --input BIOS/ ^\n --output C:\\RetroArch-Win64\\system\n</code></pre> <p>The root directory is based on where you installed RetroArch, but by default it is:</p> <pre><code>igir.exe copy extract test clean ^\n --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" ^\n --input BIOS/ ^\n --output C:\\RetroArch-Win32\\system\n</code></pre> <pre><code>igir copy extract test clean \\\n--dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" \\\n--input BIOS/ \\\n--output ~/Documents/RetroArch/system/\n</code></pre>"},{"location":"usage/desktop/retroarch/#roms","title":"ROMs","text":"<p>RetroArch is less opinionated about where your ROMs can live, you have to specify \"content\" directories during setup in the RetroArch UI.</p> <p>If you want to store your ROMs in the RetroArch folder, you could co-locate them near your BIOS files:</p> Windows (64-bit)Windows (32-bit)macOS <p>The root directory is based on where you installed RetroArch, but by default it is:</p> <pre><code>igir.exe copy zip test ^\n --dat \"No-Intro*.zip\" ^\n --input ROMs/ ^\n --output C:\\RetroArch-Win64\\roms ^\n --dir-dat-name ^\n --no-bios\n</code></pre> <p>The root directory is based on where you installed RetroArch, but by default it is:</p> <pre><code>igir.exe copy zip test ^\n --dat \"No-Intro*.zip\" ^\n --input ROMs/ ^\n --output C:\\RetroArch-Win32\\roms ^\n --dir-dat-name ^\n --no-bios\n</code></pre> <pre><code>igir copy zip test \\\n--dat \"No-Intro*.zip\" \\\n--input ROMs/ \\\n--output ~/Documents/RetroArch/roms \\\n--dir-dat-name \\\n--no-bios\n</code></pre> <p>From there, all you should have to do is \"import content\" in the RetroArch UI.</p>"},{"location":"usage/desktop/retropie/","title":"RetroPie","text":"<p>RetroPie is an installer for EmulationStation &amp; RetroArch on single-board computers (SBCs).</p>"},{"location":"usage/desktop/retropie/#bios","title":"BIOS","text":"<p>Because RetroPie uses RetroArch under the hood, the instructions are generally the same as RetroArch. By default, the RetroPie BIOS directory is <code>/home/pi/RetroPie/BIOS</code>:</p> RetroPie (Linux) <pre><code>igir copy extract test clean \\\n--dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" \\\n--input BIOS/ \\\n--output /home/pi/RetroPie/BIOS\n</code></pre>"},{"location":"usage/desktop/retropie/#roms","title":"ROMs","text":"<p>The RetroPie docs recommend creating a <code>retropie/roms</code> directory at the root of a USB drive. You can then load up this USB drive with your ROMs from a different computer:</p> WindowsmacOS <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir copy zip test clean ^\n --dat \"No-Intro*.zip\" ^\n --input \"ROMs\" ^\n --output \"E:\\retropie\\roms\" ^\n --dir-dat-name ^\n --dir-letter ^\n --no-bios\n</code></pre> <p>Replace the <code>/Volumes/RETROPIE</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy zip test clean \\\n--dat \"No-Intro*.zip\" \\\n--input \"ROMs/\" \\\n--output \"/Volumes/RETROPIE/retropie/roms/\" \\\n--dir-dat-name \\\n--dir-letter \\\n--no-bios\n</code></pre>"},{"location":"usage/handheld/onionos/","title":"OnionOS / GarlicOS","text":"<p>Info</p> <p>OnionOS is based on RetroArch, and GarlicOS is based on OnionOS, so most instructions are very similar.</p> <p>OnionOS is a popular \"OS overhaul\" for the Miyoo Mini, and GarlicOS is a similar overhaul for the Anbernic RG35XX.</p>"},{"location":"usage/handheld/onionos/#bios","title":"BIOS","text":"<p>OnionOS has its BIOS folder at the root of the SD card at <code>/BIOS</code>, and it uses the RetroArch filenames:</p> WindowsmacOS <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir.exe copy extract test clean ^\n --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" ^\n --input BIOS/ ^\n --output E:\\BIOS\n</code></pre> <p>Replace the <code>/Volumes/OnionOS</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy extract test clean \\\n--dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" \\\n--input BIOS/ \\\n--output /Volumes/OnionOS/BIOS\n</code></pre>"},{"location":"usage/handheld/onionos/#roms","title":"ROMs","text":"<p>OnionOS uses its own proprietary ROM folder structure, so <code>igir</code> has a replaceable <code>{onion}</code> token to sort ROMs into the right place. See the replaceable tokens page for more information.</p> WindowsmacOS <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir.exe copy extract test clean ^\n --dat \"No-Intro*.zip\" ^\n --input ROMs/ ^\n --output E:\\Roms\\{onion} ^\n --dir-letter ^\n --no-bios\n</code></pre> <p>Replace the <code>/Volumes/OnionOS</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy extract test clean \\\n--dat \"No-Intro*.zip\" \\\n--input ROMs/ \\\n--output /Volumes/OnionOS/Roms/{onion} \\\n--dir-letter \\\n--no-bios\n</code></pre>"},{"location":"usage/hardware/analogue-pocket/","title":"Analogue Pocket","text":"<p>The Analogue Pocket is a field-programmable gate array (FPGA) handheld that plays Game Boy, Game Boy Color, and Game Boy Advance cartridges by simulating the hardware. It can also be extended to simulate other generation 1-4 consoles &amp; handheld hardware with Analogue's openFPGA.</p> <p>These other hardware simulations are called \"cores,\" and they each expect their ROMs in a very specific directory on the Analogue Pocket's SD card.</p> <p>Tip</p> <p>You can install openFPGA cores easily with utilities such as Matt Pannella's <code>pocket_updater</code>.</p>"},{"location":"usage/hardware/analogue-pocket/#bios","title":"BIOS","text":"<p>Most Pocket updater utilities will download BIOS files required for each core for you automatically, so you shouldn't need to source &amp; sort them yourself.</p>"},{"location":"usage/hardware/analogue-pocket/#roms","title":"ROMs","text":"<p><code>igir</code> has support for replaceable \"tokens\" in the <code>--output</code> option. This makes it easier to sort ROMs on devices that have an expected directory structure. The <code>{pocket}</code> token exists to help sort ROMs on the Analogue pocket. See the replaceable tokens page for more information.</p> <p>This token can be used to reference each core's specific directory in the SD card's <code>Assets</code> directory. ROMs go in the <code>Assets/{pocket}/common</code> directory.</p> WindowsmacOS <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir copy extract test clean ^\n --dat \"No-Intro*.zip\" ^\n --input \"ROMs\" ^\n --output \"E:\\Assets\\{pocket}\\common\" ^\n --dir-letter ^\n --clean-exclude \"E:\\Assets\\*\\common\\*.*\" ^\n --no-bios\n</code></pre> <p>Replace the <code>/Volumes/POCKET</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy extract test clean \\\n--dat \"No-Intro*.zip\" \\\n--input \"ROMs/\" \\\n--output \"/Volumes/POCKET/Assets/{pocket}/common/\" \\\n--dir-letter \\\n--clean-exclude \"/Volumes/POCKET/Assets/*/common/*.*\" \\\n--no-bios\n</code></pre> <p>Note</p> <p>The <code>--clean-exclude</code> option in the above examples is so we don't accidentally \"clean\" (delete) the BIOS files for each core.</p> <p>Your SD card should look like this, likely with more cores:</p> <pre><code>\u251c\u2500\u2500 Assets\n\u2502   \u251c\u2500\u2500 genesis\n\u2502   \u2502   \u2514\u2500\u2500 common\n\u2502   \u2502       \u251c\u2500\u2500 ROM1.md\n\u2502   \u2502       \u251c\u2500\u2500 ROM2.md\n\u2502   \u2502       \u2514\u2500\u2500 ROM3.md\n\u2502   \u251c\u2500\u2500 nes\n\u2502   \u2502   \u2514\u2500\u2500 common\n\u2502   \u2502       \u251c\u2500\u2500 ROM1.nes\n\u2502   \u2502       \u251c\u2500\u2500 ROM2.nes\n\u2502   \u2502       \u2514\u2500\u2500 ROM3.nes\n\u2502   \u251c\u2500\u2500 sms\n\u2502   \u2502   \u2514\u2500\u2500 common\n\u2502   \u2502       \u251c\u2500\u2500 ROM1.sms\n\u2502   \u2502       \u251c\u2500\u2500 ROM2.sms\n\u2502   \u2502       \u2514\u2500\u2500 ROM3.sms\n\u2502   \u251c\u2500\u2500 snes\n\u2502   \u2502   \u2514\u2500\u2500 common\n\u2502   \u2502       \u251c\u2500\u2500 ROM1.snes\n\u2502   \u2502       \u251c\u2500\u2500 ROM2.snes\n\u2502   \u2502       \u2514\u2500\u2500 ROM3.snes\n\u251c\u2500\u2500 Cores\n\u251c\u2500\u2500 Platforms\n\u2514\u2500\u2500 Presets\n</code></pre>"},{"location":"usage/hardware/everdrive/","title":"EverDrive","text":""},{"location":"usage/hardware/everdrive/#roms","title":"ROMs","text":"<p>Because flash carts are specific to a specific console, you can provide specific input directories &amp; DATs when you run <code>igir</code>. For example:</p> WindowsmacOS <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir.exe copy extract test clean ^\n --dat \"Nintendo - Game Boy.dat\" ^\n --input \"ROMs-Sorted/Nintendo - Game Boy\" ^\n --output E:\\ ^\n --no-bios\n</code></pre> <p>Replace the <code>/Volumes/EverDrive</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy extract test clean \\\n--dat \"Nintendo - Game Boy.dat\" \\\n--input \"ROMs-Sorted/Nintendo - Game Boy\" \\\n--output /Volumes/EverDrive/ \\\n--no-bios\n</code></pre> <p>you can then add some other output options such as <code>--dir-letter</code>, if desired.</p> <p>Alternatively, <code>igir</code> supports Hardware Target Game Database SMDB files as DATs. Unlike typical DATs, Hardware Target Game Database SMDBs typically have an opinionated directory structure to help sort ROMs by language, category, genre, and more. Example usage:</p> WindowsmacOS <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir.exe copy extract test clean ^\n --dat \"https://raw.githubusercontent.com/frederic-mahe/Hardware-Target-Game-Database/master/EverDrive%20Pack%20SMDBs/EverDrive%20GB%20SMDB.txt\" ^\n --input \"ROMs-Sorted/Nintendo - Game Boy\" ^\n --output E:\\\n</code></pre> <p>Replace the <code>/Volumes/EverDrive</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy extract test clean \\\n--dat \"https://raw.githubusercontent.com/frederic-mahe/Hardware-Target-Game-Database/master/EverDrive%20Pack%20SMDBs/EverDrive%20GB%20SMDB.txt\" \\\n--input \"ROMs-Sorted/Nintendo - Game Boy\" \\\n--output /Volumes/EverDrive/\n</code></pre>"},{"location":"usage/hardware/mister/","title":"MiSTer FPGA","text":"<p>The MiSTer FPGA is a set of software for field-programmable gate array (FPGA) development boards that simulates consoles &amp; handheld hardware. This means it can play games with perfect simulation.</p>"},{"location":"usage/hardware/mister/#bios","title":"BIOS","text":"<p>The MiSTer <code>update_all.sh</code> script can download BIOS files required for each core automatically, so you shouldn't need to source &amp; sort them yourself.</p>"},{"location":"usage/hardware/mister/#roms","title":"ROMs","text":"<p><code>igir</code> has support for replaceable \"tokens\" in the <code>--output</code> option. This makes it easier to sort ROMs on devices that have an expected directory structure. The <code>{mister}</code> token exists to help sort ROMs on the MiSTer. See the replaceable tokens page for more information.</p> <p>This token can be used to reference each core's specific directory in the MiSTer's <code>games</code> directory.</p> WindowsmacOS <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir copy extract test clean ^\n --dat \"No-Intro*.zip\" ^\n --input \"ROMs\" ^\n --output \"E:\\games\\{mister}\" ^\n --dir-letter ^\n --no-bios\n</code></pre> <p>Replace the <code>/Volumes/MISTER</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy extract test clean \\\n--dat \"No-Intro*.zip\" \\\n--input \"ROMs/\" \\\n--output \"/Volumes/MISTER/games/{mister}/\" \\\n--dir-letter \\\n--no-bios\n</code></pre>"}]}